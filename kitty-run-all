#!/usr/bin/env python
from __future__ import annotations

import argparse
import json
import os
import queue
import secrets
import shlex
import socket
import subprocess
import sys
import tempfile
import threading
import time

SCRIPT_PATH = os.path.realpath(__file__)
ACK_USER_VAR = "KITTY_RUN_ALL_ACK"

def _ipc_env_prefix(ipc_server) -> str:
    return (f"KITTY_RUN_ALL_IPC_SOCKET={shlex.quote(ipc_server.socket_path)} "
            f"KITTY_RUN_ALL_IPC_TOKEN={shlex.quote(ipc_server.token)}")


def wrap_command(command, ipc_server) -> str:
    prefix = _ipc_env_prefix(ipc_server)
    return (f"{command}; set -l exit_code $status; "
            f"{prefix} {shlex.quote(SCRIPT_PATH)} --call-from-separate-window $exit_code")

def parse_spec(args, parser) -> list[list[str]]:
    if args.commands[0] == "\\":
        parser.error("Invalid command list: leading '-' is not allowed")

    command_rows = [[args.commands[0]]]
    previous_was_pipe = False
    for token in args.commands[1:]:
        if token == "\\":
            if previous_was_pipe:
                parser.error("Invalid command list: consecutive '\\' is not allowed")
            previous_was_pipe = True
            continue

        if previous_was_pipe:
            # Start a new row for horizontal split
            command_rows.append([token])
        else:
            # Add to the current row for vertical split
            command_rows[-1].append(token)

        previous_was_pipe = False

    if previous_was_pipe:
        parser.error("Invalid command list: trailing '\\' is not allowed")
    return command_rows

class IpcServer:
    def __init__(self):
        self._tempdir = tempfile.TemporaryDirectory(prefix="kitty-run-all-")
        self.socket_path = os.path.join(self._tempdir.name, "ipc.sock")
        self.token = secrets.token_hex(16)
        self._notify_queue: queue.Queue[dict[str, object]] = queue.Queue()
        self._stop_event = threading.Event()
        self._listener = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        try:
            self._listener.bind(self.socket_path)
            self._listener.listen()
        except OSError:
            self._tempdir.cleanup()
            raise
        self._worker = threading.Thread(target=self._serve, daemon=True)
        self._worker.start()

    def _serve(self) -> None:
        while not self._stop_event.is_set():
            try:
                conn, _ = self._listener.accept()
            except OSError:
                break
            threading.Thread(target=self._handle_connection, args=(conn,), daemon=True).start()

    def _handle_connection(self, conn: socket.socket) -> None:
        with conn:
            data = b""
            while not data.endswith(b"\n"):
                chunk = conn.recv(4096)
                if not chunk:
                    break
                data += chunk
            if not data:
                return
            try:
                payload = json.loads(data.decode())
            except json.JSONDecodeError:
                return
            if payload.get("token") != self.token:
                return
            window_id = payload.get("window_id")

            self._notify_queue.put({
                "window_id": window_id,
                "status": payload.get("status"),
                "pid": payload.get("pid"),
                "timestamp": payload.get("timestamp")
            })

    def drain_notifications(self) -> list[dict[str, object]]:
        entries: list[dict[str, object]] = []
        while True:
            try:
                entries.append(self._notify_queue.get_nowait())
            except queue.Empty:
                break
        return entries

    def read_notification(self) -> dict[str, object] | None:
        try:
            return self._notify_queue.get(timeout=1.0)
        except queue.Empty:
            return None

    def stop(self) -> None:
        self._stop_event.set()
        try:
            self._listener.close()
        except OSError:
            pass
        self._worker.join(timeout=1)
        self._tempdir.cleanup()


def notify_parent(exit_code: int) -> None:
    socket_path = os.environ.get("KITTY_RUN_ALL_IPC_SOCKET")
    token = os.environ.get("KITTY_RUN_ALL_IPC_TOKEN")
    if not socket_path or not token:
        return
    payload = json.dumps({
        "type": "done",
        "token": token,
        "window_id": os.environ.get("KITTY_WINDOW_ID"),
        "status": exit_code,
        "pid": os.getpid(),
        "timestamp": time.time()
    })
    notified = False
    try:
        with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:
            sock.connect(socket_path)
            sock.sendall(payload.encode() + b"\n")
            notified = True
    except OSError as exc:
        print(f"Warning: IPC handshake failed: {exc}", file=sys.stderr)
    window_id = os.environ.get("KITTY_WINDOW_ID")
    if notified and window_id:
        wait_for_window_ack(window_id, token)

def launch_command_in_new_window(location, next_to, command) -> str:
    new_window = subprocess.check_output([
        "kitty", "@", "launch", "--type=window", "--cwd", os.getcwd(), "--dont-take-focus",
        f"--location={location}", f"--next-to=id:{next_to}", "fish", "-c" f"{command}"]
    ).strip().decode('utf-8')

    return new_window

def create_windows(commands, current_window, ipc_server) -> tuple[list[list[str]], dict[str, str]]:
    # Initialize the list of windows with the current window
    window_rows = [[current_window]]
    command_map: dict[str, str] = {}

    # Split windows until we have enough for all commands
    for row_index, commands_in_row in enumerate(commands):
        # Skip the first row since it's already the current window
        if row_index == 0:
            continue

        wrapped = wrap_command(commands_in_row[0], ipc_server)

        new_window = launch_command_in_new_window("hsplit", window_rows[row_index-1][0], wrapped)

        window_rows.append([new_window])
        command_map[new_window] = commands_in_row[0]
    return window_rows, command_map

def create_horizontal_windows(commands, windows, command_map: dict[str, str], ipc_server):
    for row_index, commands_in_row in enumerate(commands):
        windows_in_row = windows[row_index]

        for idx, command in enumerate(commands_in_row[1:]):
            wrapped = wrap_command(command, ipc_server)

            new_window = launch_command_in_new_window("vsplit", windows_in_row[idx-1], wrapped)

            windows_in_row.append(new_window)
            command_map[new_window] = command


def focus_window(current_window):
    subprocess.run([
        "kitty", "@", "focus-window", f"--match=id:{current_window}"
    ])


def get_current_window() -> str:
    current_window = os.environ.get("KITTY_WINDOW_ID")
    if not current_window:
        print("Error: KITTY_WINDOW_ID environment variable is not set.")
        sys.exit(1)
    return current_window


def collect_window_ids_for_wait(windows: list[list[str]], current_window: str) -> set[str]:
    ids: set[str] = set()
    for row in windows:
        for window_id in row:
            if window_id != current_window:
                ids.add(window_id)
    return ids


def list_window_infos() -> dict[str, dict[str, object]] | None:
    try:
        result = subprocess.run([
            "kitty", "@", "ls"
        ], capture_output=True, text=True)
    except OSError:
        return None

    if result.returncode != 0 or not result.stdout:
        return None

    try:
        windows_info = json.loads(result.stdout)
    except json.JSONDecodeError:
        return None

    infos: dict[str, dict[str, object]] = {}
    for os_window in windows_info:
        for tab in os_window.get("tabs", []):
            for window in tab.get("windows", []):
                window_id = window.get("id")
                if window_id is not None:
                    infos[str(window_id)] = window
    return infos


def wait_for_window_ack(window_id: str, token: str, timeout: float = 60.0, interval: float = 0.25) -> None:
    deadline = time.time() + timeout
    while time.time() < deadline:
        infos = list_window_infos()
        if infos is None:
            print("Warning: unable to query kitty windows for ACK", file=sys.stderr)
            return
        entry = infos.get(window_id)
        if entry:
            user_vars = entry.get("user_vars")
            if isinstance(user_vars, dict) and user_vars.get(ACK_USER_VAR) == token:
                return
        time.sleep(interval)
    print(f"Warning: timed out waiting for ack on window {window_id}", file=sys.stderr)

def print_window_output(window_id: str, command: str | None, status: int | None = None) -> None:
    label = command or window_id
    suffix = f" (exit {status})" if status is not None else ""
    header = f"\x1b[32m=== Output from window '{label}'{suffix} ===\x1b[0m"
    print(header)
    try:
        result = subprocess.run([
            "kitty", "@", "get-text",
            f"--match=id:{window_id}",
            "--ansi", "--extent=last_cmd_output"
        ], capture_output=True, text=True)
    except OSError:
        print(f"Warning: failed to get output for window {window_id}", file=sys.stderr)
        return

    if result.returncode != 0:
        print(f"Warning: failed to get output for window {window_id}: {result.stderr}", file=sys.stderr)
        return

    output = result.stdout
    if output:
        print(output, end="" if output.endswith("\n") else "\n")


def close_window(window_id: str) -> None:
    subprocess.run([
        "kitty", "@", "close-window", f"--match=id:{window_id}"
    ])


def set_window_user_var(window_id: str, key: str, value: str) -> None:
    subprocess.run([
        "kitty", "@", "set-user-vars",
        f"--match=id:{window_id}", f"{key}={value}"
    ], check=False)


def acknowledge_window(window_id: str, token: str) -> None:
    set_window_user_var(window_id, ACK_USER_VAR, token)


def print_remaining_status(remaining) -> None:
    count = len(remaining)
    if not count:
        return

    plural = "" if count == 1 else "s"
    message = f"Waiting for {count} window{plural} to close..."

    print(message, end='\r', flush=True)

def wait_for_windows(window_ids: set[str], close_windows: bool, command_map: dict[str, str], ipc_server: IpcServer | None = None) -> None:
    remaining = set(window_ids)
    if not remaining:
        return

    ack_token = ipc_server.token if ipc_server else None
    acked_windows: set[str] = set()
    printed_status = False
    try:
        while remaining:
            entry = ipc_server.read_notification() if ipc_server else None
            if entry:
                window_id = entry.get("window_id")
                status = entry.get("status")
                if window_id:
                    print_window_output(window_id, command_map.get(window_id), status if isinstance(status, int) else None)
                    if ack_token and window_id not in acked_windows:
                        acknowledge_window(window_id, ack_token)
                        acked_windows.add(window_id)
                        if close_windows:
                            close_window(window_id)

            window_infos = list_window_infos()
            if window_infos is None:
                print("Warning: unable to query kitty windows, skipping wait.", file=sys.stderr)
                break

            closed_windows = {wid for wid in remaining if wid not in window_infos}
            for wid in closed_windows:
                remaining.remove(wid)

            if remaining:
                print_remaining_status(remaining)
                printed_status = True
                time.sleep(0.5)
    finally:
        if printed_status:
            print()


def main():
    parser = argparse.ArgumentParser(
        prog='kitty-run-all',
        description="Run multiple commands in split Kitty windows.\n"
                    "Use '-' before a command to create a horizontal split instead of the default vertical split.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage="%(prog)s [options] <command1> [| <command2>] <command3> ..."
    )
    parser.add_argument('--dont-close', action='store_true',
                        help="Keep windows open instead of closing them automatically")
    parser.add_argument('--wait', action='store_true',
                        help="Wait for all commands to finish before returning")
    parser.add_argument('--call-from-separate-window', type=int, nargs='?',
                        const=0, help=argparse.SUPPRESS)
    parser.add_argument('commands', nargs='*',
                        help="Commands to run")
    args = parser.parse_args()
    if args.call_from_separate_window is not None:
        notify_parent(args.call_from_separate_window)
        sys.exit(args.call_from_separate_window)
    if not args.commands:
        parser.error("the following arguments are required: commands")

    ipc_server = IpcServer()

    try:
        commands = parse_spec(args, parser)

        current_window = get_current_window()

        windows, window_command_map = create_windows(commands, current_window, ipc_server)

        create_horizontal_windows(commands, windows, window_command_map, ipc_server)
        windows_to_wait: set[str] | None = None
        if args.wait:
            windows_to_wait = collect_window_ids_for_wait(windows, current_window)

        close_windows = not args.dont_close

        focus_window(current_window)

        # Run the first command in the current window
        subprocess.run(["fish", "-c", commands[0][0]])

        if args.wait and windows_to_wait:
            wait_for_windows(windows_to_wait, close_windows, window_command_map, ipc_server)
    finally:
        ipc_server.stop()


if __name__ == "__main__":
    main()
