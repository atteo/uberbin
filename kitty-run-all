#!/usr/bin/env python

import json
import os
import subprocess
import sys
import time
import argparse

def parse_spec(args, parser) -> list[list[str]]:
    if args.commands[0] == "\\":
        parser.error("Invalid command list: leading '-' is not allowed")

    command_rows = [[args.commands[0]]]
    previous_was_pipe = False
    for token in args.commands[1:]:
        if token == "\\":
            if previous_was_pipe:
                parser.error("Invalid command list: consecutive '\\' is not allowed")
            previous_was_pipe = True
            continue

        if previous_was_pipe:
            # Start a new row for horizontal split
            command_rows.append([token])
        else:
            # Add to the current row for vertical split
            command_rows[-1].append(token)

        previous_was_pipe = False

    if previous_was_pipe:
        parser.error("Invalid command list: trailing '\\' is not allowed")
    return command_rows


def wrap_command(command) -> str:
    return command


def create_windows(commands, current_window) -> tuple[list[list[str]], dict[str, str]]:
    # Initialize the list of windows with the current window
    window_rows = [[current_window]]
    command_map: dict[str, str] = {}

    # Split windows until we have enough for all commands
    for row_index, commands_in_row in enumerate(commands):
        # Skip the first row since it's already the current window
        if row_index == 0:
            continue

        wrapped = wrap_command(commands_in_row[0])

        new_window = launch_command_in_new_window("hsplit", window_rows[row_index-1][0], wrapped)

        window_rows.append([new_window])
        command_map[new_window] = commands_in_row[0]
    return window_rows, command_map


def launch_command_in_new_window(location, next_to, command) -> str:
    new_window = subprocess.check_output([
        "kitty", "@", "launch", "--type=window", "--cwd", os.getcwd(), "--dont-take-focus",
        f"--location={location}", f"--next-to=id:{next_to}", "fish", "-c" f"{command}"]
    ).strip().decode('utf-8')

    return new_window


def create_horizontal_windows(commands, windows, command_map: dict[str, str]):
    for row_index, commands_in_row in enumerate(commands):
        windows_in_row = windows[row_index]

        for idx, command in enumerate(commands_in_row[1:]):
            wrapped = wrap_command(command)

            new_window = launch_command_in_new_window("vsplit", windows_in_row[idx-1], wrapped)

            windows_in_row.append(new_window)
            command_map[new_window] = command


def focus_window(current_window):
    subprocess.run([
        "kitty", "@", "focus-window", f"--match=id:{current_window}"
    ])


def get_current_window() -> str:
    current_window = os.environ.get("KITTY_WINDOW_ID")
    if not current_window:
        print("Error: KITTY_WINDOW_ID environment variable is not set.")
        sys.exit(1)
    return current_window


def collect_window_ids_for_wait(windows: list[list[str]], current_window: str) -> set[str]:
    ids: set[str] = set()
    for row in windows:
        for window_id in row:
            if window_id != current_window:
                ids.add(window_id)
    return ids


def list_window_infos() -> dict[str, dict[str, object]] | None:
    try:
        result = subprocess.run([
            "kitty", "@", "ls"
        ], capture_output=True, text=True)
    except OSError:
        return None

    if result.returncode != 0 or not result.stdout:
        return None

    try:
        windows_info = json.loads(result.stdout)
    except json.JSONDecodeError:
        return None

    infos: dict[str, dict[str, object]] = {}
    for os_window in windows_info:
        for tab in os_window.get("tabs", []):
            for window in tab.get("windows", []):
                window_id = window.get("id")
                if window_id is not None:
                    infos[str(window_id)] = window
    return infos


def get_window_output(window_id: str) -> str | None:
    try:
        result = subprocess.run([
            "kitty", "@", "get-text",
            f"--match=id:{window_id}",
            "--ansi", "--extent=last_cmd_output"
        ], capture_output=True, text=True)
    except OSError:
        return None

    if result.returncode != 0:
        return None

    return result.stdout


def print_window_output(window_id: str, command: str | None, output: str | None) -> None:
    label = command or window_id
    header = f"\x1b[32m=== Output from window {label} ===\x1b[0m"
    print(f"\n{header}")
    if output:
        print(output, end="" if output.endswith("\n") else "\n")
    else:
        print("(no output captured)")


def close_window(window_id: str) -> None:
    subprocess.run([
        "kitty", "@", "close-window", f"--match=id:{window_id}"
    ])


def wait_for_windows(window_ids: set[str], close_windows: bool, command_map: dict[str, str]) -> None:
    remaining = set(window_ids)
    if not remaining:
        return

    last_count = -1
    status_message = ""
    window_output: dict[str, str | None] = {}
    waiting_for_prompt: set[str] = set(window_ids)
    printed: set[str] = set()
    closing_windows: set[str] = set()
    try:
        while remaining:
            window_infos = list_window_infos()
            if window_infos is None:
                print("Warning: unable to query kitty windows, skipping wait.", file=sys.stderr)
                break

            alive = remaining & set(window_infos.keys())

            done_prompt = {wid for wid in waiting_for_prompt & alive if window_infos[wid].get("at_prompt")}
            for window_id in done_prompt:
                command = command_map.get(window_id)

                output = get_window_output(window_id)
                window_output[window_id] = output

                if window_id not in printed:
                    print_window_output(window_id, command, window_output.get(window_id))
                    printed.add(window_id)
                waiting_for_prompt.discard(window_id)
                if close_windows and window_id not in closing_windows:
                    close_window(window_id)
                    closing_windows.add(window_id)
                if not close_windows:
                    remaining.discard(window_id)
                if status_message:
                    print(status_message, end='\r', flush=True)

            missing = remaining - alive
            for window_id in list(missing):
                command = command_map.get(window_id)
                if window_id not in printed:
                    print_window_output(window_id, command, window_output.get(window_id))
                    printed.add(window_id)
                remaining.discard(window_id)
                waiting_for_prompt.discard(window_id)
                closing_windows.discard(window_id)
                if status_message:
                    print(status_message, end='\r', flush=True)

            count = len(remaining)
            if count:
                plural = "" if count == 1 else "s"
                message = f"Waiting for {count} window{plural} to close..."
                if count != last_count:
                    print(message, end='\r', flush=True)
                    status_message = message
                    last_count = count
            else:
                status_message = ""

            if remaining:
                time.sleep(0.5)
    finally:
        if last_count != -1:
            print()


def main():
    parser = argparse.ArgumentParser(
        prog='kitty-run-all',
        description="Run multiple commands in split Kitty windows.\n"
                    "Use '-' before a command to create a horizontal split instead of the default vertical split.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage="%(prog)s [options] <command1> [| <command2>] <command3> ..."
    )
    parser.add_argument('--dont-close', action='store_true',
                        help="Keep windows open instead of closing them automatically")
    parser.add_argument('--wait', action='store_true',
                        help="Wait for all commands to finish before returning")
    parser.add_argument('commands', nargs='+',
                        help="Commands to run")
    args = parser.parse_args()

    commands = parse_spec(args, parser)

    current_window = get_current_window()

    windows, window_command_map = create_windows(commands, current_window)

    create_horizontal_windows(commands, windows, window_command_map)
    windows_to_wait: set[str] | None = None
    if args.wait:
        windows_to_wait = collect_window_ids_for_wait(windows, current_window)

    close_windows = not args.dont_close

    focus_window(current_window)

    # Run the first command in the current window
    subprocess.run(["fish", "-c", wrap_command(commands[0][0])])

    if args.wait and windows_to_wait:
        wait_for_windows(windows_to_wait, close_windows, window_command_map)


if __name__ == "__main__":
    main()
